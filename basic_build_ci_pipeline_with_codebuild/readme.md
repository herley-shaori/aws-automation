

# Terraform-Driven CI Pipeline with CodeCommit, CodeBuild & CodePipeline 🚀

## Overview 🎯
This project demonstrates how to set up a Continuous Integration (CI) pipeline using Terraform and AWS services. On each commit to the CodeCommit repository, the pipeline automatically triggers a build, installs dependencies, runs unit tests, and publishes test results—without any deployment step.

**Key AWS Services:**
- **AWS CodeCommit**: Git-based source code repository.
- **AWS CodeBuild**: Build service that compiles, runs tests, and generates reports.
- **AWS CodePipeline**: Orchestrates the CI workflow (Source → Build).
- **Amazon S3**: Stores pipeline artifacts (source code zips, build logs).
- **AWS IAM**: Manages roles and policies to give services the necessary permissions.

---

## Goals & Requirements ✔️
1. **CI Only**: Focus on compiling/running tests on every commit. No deployment to production.  
2. **Terraform as Code**: All infrastructure (repos, build projects, pipelines, IAM roles) is defined in Terraform.  
3. **Sample Application + Tests**: A minimal Python “add” function and pytest unit tests to illustrate build/test execution.  
4. **Automatic Trigger**: Each `terraform apply` (or Git commit to `main`) kicks off the pipeline.  
5. **Automated Reporting**: Test results are published as JUnit‐style reports in CodeBuild.

---

## Files & Structure 📁
```
basic_build_ci_pipeline_with_codebuild/
├── main.tf                ← Terraform configuration for the entire CI pipeline
├── readme.md              ← (This file) explains setup, architecture, and usage
└── my-repo-contents/      ← Local folder mirroring CodeCommit contents
    ├── hello.html         ← Sample static HTML (pushed to CodeCommit but not used in build)
    ├── buildspec.yml      ← Instructions for CodeBuild to install pytest & run tests
    └── app/
        ├── main.py        ← Simple Python function (`add(a, b)`)
        └── test_main.py   ← Pytest unit tests for `main.py`
```

- **`main.tf`**:  
  - Ensures local file creation (`hello.html`, `buildspec.yml`, `app/main.py`, `app/test_main.py`) in `my-repo-contents/`.  
  - Pushes those files into CodeCommit `my-repo/main` via `null_resource.push_files`.  
  - Provisions:
    - **CodeCommit** repository (`my-repo`).  
    - **CodeBuild** project (`hello-codebuild-project`) configured to use `buildspec.yml`.  
    - **CodePipeline** (`build-pipeline`) with a Source stage (CodeCommit) and a Build stage (CodeBuild).  
    - **IAM Roles & Policies** for CodePipeline and CodeBuild with all required permissions.  
    - **S3 Bucket** (`pipeline-artifacts-<suffix>`) for pipeline artifacts.  
  - A `null_resource.execute_pipeline` always invokes `aws codepipeline start-pipeline-execution` on every `terraform apply`.

- **`my-repo-contents/hello.html`**:  
  - A placeholder HTML file generated by Terraform—pushed to CodeCommit but not used in the Python build/test. This demonstrates how local files can be versioned and pushed by Terraform.

- **`my-repo-contents/buildspec.yml`**:  
  - Tells CodeBuild to:
    1. **Install** pytest (Python 3.8).  
    2. **Run** `pytest` to execute unit tests (`app/test_main.py`).  
    3. **Generate** a JUnit XML report under `reports/junit.xml`.

- **`my-repo-contents/app/main.py`**:  
  - A minimal Python function:
    ```python
    def add(a, b):
        return a + b

    if __name__ == "__main__":
        print("Add 2 + 3 =", add(2, 3))
    ```

- **`my-repo-contents/app/test_main.py`**:  
  - Pytest unit tests verifying:
    - `add(2, 3) == 5`
    - `add(-1, -1) == -2`

---

## Architecture Diagram 🏗️
```
          Local Terraform
           (main.tf)
              │
              ▼
    +------------------------+
    | Create/Push Local Files|
    | (hello.html, buildspec,|
    |   app/main.py, tests)  |
    +-----------+------------+
                │
                ▼
    +------------------------+
    |  AWS CodeCommit (my-repo) ──┐
    |  • Branch = main            |
    +-----------+-----------------+
                │
                ▼
    +------------------------+
    |  AWS CodePipeline     |
    |  • Source stage (CC)  |
    |  • Build stage (CB)   |
    +-----------+------------+
                │
                ▼
    +------------------------+
    |  AWS CodeBuild        |
    |  • Install pytest     |
    |  • Run pytest tests   |
    |  • Publish JUnit XML  |
    +------------------------+
```

---

## Setup & Execution Steps 🔧

1. **Clone or Navigate** to your project directory:
   ```bash
   cd basic_build_ci_pipeline_with_codebuild
   ```

2. **Initialize Terraform**:
   ```bash
   terraform init
   ```

3. **Apply Terraform Configuration**:
   ```bash
   terraform apply -auto-approve
   ```
   - **Outcome**:  
     1. Creates `my-repo` in CodeCommit.  
     2. Writes `hello.html`, `buildspec.yml`, `app/main.py`, and `app/test_main.py` under `my-repo-contents/`.  
     3. Pushes those files into `my-repo/main`.  
     4. Establishes an S3 bucket for pipeline artifacts.  
     5. Creates IAM roles/policies allowing CodePipeline → CodeBuild → S3 → Logs permissions.  
     6. Creates a CodeBuild project (`hello-codebuild-project`).  
     7. Creates a CodePipeline (`build-pipeline`) that watches `my-repo/main`.  
     8. Immediately invokes `start-pipeline-execution` through a `null_resource` to kick off the first pipeline run.

4. **Monitor Pipeline Execution**:
   - In the AWS Console → **CodePipeline** → Select **build-pipeline**.  
   - You should see stages:
     - **Source**: Fetching from `my-repo/main`.
     - **Build**: CodeBuild running with the updated `buildspec.yml`.
   - **Verify CodeBuild**:
     - In the AWS Console → **CodeBuild** → Select **hello-codebuild-project** → **Build history**.  
     - Check logs: you’ll see “Installing pytest…” and “collected 2 items” → “2 passed” indicating your unit tests ran successfully.

5. **Verify Test Reports**:
   - Inside the CodeBuild logs, you should see JUnit report files under `/reports/junit.xml`.  
   - CodeBuild automatically uploads these results to a CloudWatch Log Group and can publish to a CodeBuild Report Group named `hello-codebuild-project-pytest-report`.

---

## How It Works 🤖

1. **Local File Generation**:  
   - Terraform `local_file` resources create:
     - `hello.html`
     - `buildspec.yml` (with pytest instructions)
     - `app/main.py` and `app/test_main.py`  
   - All files live under `my-repo-contents/`.

2. **Push to CodeCommit**:  
   - `null_resource.push_files` uses AWS CLI to:
     - Check if `main` branch exists.  
     - If it does, run `codecommit put-file` with `parent-commit-id` to update existing files.  
     - If not, create branch `main` and add files.  
   - Dependencies on `local_file` resources ensure all files exist before pushing.

3. **Pipeline Artifacts**:  
   - Terraform creates an S3 bucket (`pipeline-artifacts-<random>`) to store:
     - Source zips from CodeCommit.
     - Any generated build artifacts (none in this CI-only scenario).

4. **IAM Roles & Permissions**:
   - **CodePipeline Role**:
     - Allows reading from CodeCommit (GetBranch, GitPull, etc.).
     - Allows starting CodeBuild builds.
     - Allows S3 read/write on artifact bucket.
   - **CodeBuild Role**:
     - Allows all CodeBuild actions (`codebuild:*`).
     - Allows S3 read (`s3:GetObject`, etc.) so it can pull sources.
     - Allows CloudWatch Logs and CloudWatch metrics (logs:\* and cloudwatch:\*).

5. **CodeBuild Execution**:
   - Uses `buildspec.yml`:
     ```yaml
     version: 0.2

     phases:
       install:
         runtime-versions:
           python: 3.8
         commands:
           - pip install pytest
       build:
         commands:
           - pytest --junitxml=reports/junit.xml

     reports:
       pytest-report:
         files:
           - reports/junit.xml
         base-directory: reports
     ```
   - **INSTALL phase**: Installs pytest under Python 3.8.  
   - **BUILD phase**: Runs `pytest`; test output is recorded in `reports/junit.xml`.  
   - **UPLOAD_ARTIFACTS phase**: Publishes the JUnit XML to the CodeBuild report group.

6. **Automatic Trigger**:
   - `null_resource.execute_pipeline` has `triggers = { always = timestamp() }`, forcing it to execute on every `terraform apply`.  
   - It runs:  
     ```
     aws codepipeline start-pipeline-execution --name build-pipeline --region ap-southeast-3
     ```
   - This means you don’t need to manually “Release Change” in CodePipeline; Terraform does it for you.

---

## Customizing & Extending 🛠️

- **Switch to GitHub**:  
  - Replace the CodeCommit source in `aws_codebuild_project` and `aws_codepipeline` with a CodeStar connection to GitHub.  
  - You will need to set up a CodeStar connection ARN manually and reference it in Terraform.

- **Add Additional Tests**:  
  - Add more `.py` files under `my-repo-contents/app/` and extend `buildspec.yml` to install any extra dependencies (e.g., `requirements.txt` or `npm install` for Node.js).

- **Publish Artifacts**:  
  - Modify `aws_codebuild_project` to produce build artifacts (e.g., a zip file).  
  - Add an S3 upload step in the `buildspec.yml` `post_build` phase if you want to store compiled binaries or packages.

- **Notifications**:  
  - Integrate SNS or EventBridge rules to notify developers on build failures or successes.  
  - Example: add an SNS topic subscription in the `buildspec.yml` post‐build phase or configure a CloudWatch Event on CodeBuild build state changes.

---

## Cleanup & Teardown 🧹

1. **Destroy Terraform Resources**:
   ```bash
   terraform destroy -auto-approve
   ```
   This will delete:
   - CodePipeline (`build-pipeline`)
   - CodeBuild project (`hello-codebuild-project`)
   - IAM roles and policies for CodePipeline and CodeBuild  
   - S3 bucket for pipeline artifacts (and all its contents)
   - CodeCommit repository (`my-repo`)
   - Any local remnants can be removed manually if desired.

2. **Confirm Deletion**:
   - Check the AWS Console to ensure:
     - `my-repo` no longer exists under CodeCommit.  
     - S3 bucket `pipeline-artifacts-<suffix>` is deleted.  
     - CodePipeline and CodeBuild entries are gone.  
     - IAM roles/policies no longer appear.

---

## Congratulations! 🎉

You now have a fully automated, Terraform‐driven CI pipeline that checks out code, installs dependencies, runs pytest tests, and provides quick feedback on every change to the main branch. Feel free to extend this pattern to other languages, frameworks, or deployment stages as you build out your CI/CD workflows! 🚀